# -*- coding: utf-8 -*-
"""MovieRecomendation.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1JwfeFmbsjrKjv9q09WE8ruymWPjY5xJn
"""

!pip install surprise

import pandas as pd
import numpy as np
from sklearn.model_selection import cross_validate
from surprise import SVD, Dataset, Reader
from surprise.accuracy import rmse
from surprise.accuracy import mae

df = pd.read_csv('ratings.csv')
#checking missing values

df.isnull().sum()

df.shape

df.head()

#removing timestamp 
df.drop('timestamp',axis=1,inplace=True)

n_users = df['userId'].nunique()
n_movies = df['movieId'].nunique()
print("Number of users ",n_users)
print("Number of movies ",n_movies)

#checking reviews
df['rating'].value_counts().plot(kind = 'bar')

#Data Cleaning 
#1. Movies which were rated less than 3 time
filter_movies = df['movieId'].value_counts() > 3
filter_movies = filter_movies[filter_movies].index.tolist()

#2. filter users with less than 3 movies rated
filter_users = df['userId'].value_counts() > 3
filter_users = filter_users[filter_users].index.tolist()

df = df[(df['movieId'].isin(filter_movies)) & (df['userId'].isin(filter_users))]



#creating the surprise dataset
cols = ['userId', 'movieId' , 'rating']
reader = Reader(rating_scale=(0.5,5))
data = Dataset.load_from_df(df[cols],reader)

train_set = data.build_full_trainset() 
antiset = train_set.build_anti_testset() #antiset contains pair where ratings and movie are low

#training our model
""" We will use SVD (Singular value Decompostion)
    Interaction Matrix = A X B X C"""
svd = SVD(n_epochs =25 , verbose =True)


cross_validate(svd, data ,score=['RMSE','MAE'], cv=5,verbose =True )

prediction = svd.test(antiset)

""" FOR TOP 3 prediction to a particular user""""
from collections import defaultdict
def get_top_n(predictions, n):
  top_n = defaultdict(list)
  for uid, iid, _, est, _ in predictions:
    top_n[uid].append((iid,est))
  for uid, user_ratings in top_n.keys():
    user_ratings.sort(key= lambda x: x[1],reverse= True)
    top_n[uid] = user_ratings[:n]
  return top_n
top_n(prediction,3) 

for uid, user_ratings in top_n.items():
  print(uid, [iid for (iid,rating) in user_rating])
